---
---

### Basics



#### How SVGs are written

SVGs are just plain text files that contain descriptions of what shapes to draw.
You can create or edit them in any text editor.
You can also use software like Inkscape or Adobe Illustrator to make more complex SVGs, but they are still saved and represented as plain text.

SVGs are written in a simple markup language called XML that consists of three main concepts:

1. Elements (written with "tags") - the individual components or building blocks of your image
2. Element attributes - the properties attached to an element that describes its appearance, behavior, etc
3. Element hierarchy - the organizational structure of the document, formed by arranging elements in an order or nesting them within one another

```xml
<element attribute="value">
  <child attribute="value">
    ...more content...
  </child>
  <child attribute="value" />
</element>
<!-- comment -->
```

Element with children elements inside:

```xml
<element><child>...</child></element>
```

Element with attribute:

```xml
<element attribute="value">...</element>
```

Self-closing/empty element:

```xml
<element attribute="value" />
```

XML is generally whitespace-insensitive, so you'll see slightly different ways to format SVGs throughout this presentation and in online examples.



#### Coordinate system

An SVG has an abstract coordinate system with arbitrary units called "SVG units" or "user units".
It is a Cartesian coordinate space -- **positive down and to the right** -- that eventually gets mapped to some real world space.
The coordinates/dimensions/etc of all elements are given in this space, as plain numerical values.

```xml
<element
  some-coordinate="-100"
  some-dimension="34.5"
>
```
{:.col}

{% include code-image.html src="2-basics/coordinates.svg" %}



#### The `<svg>` tag

In every SVG, there is a top level `<svg>` element that contains all of the contents of the image and some key properties of the image. There are only 4 attributes you will likely ever use in this element: `xmlns`, `viewBox`, `width`, and `height`.

```xml
<svg
  xmlns="http://www.w3.org/2000/svg"
  viewBox="..."
  width="..."
  height="..."
>
  ...
</svg>
```

In SVGs generated by software, you will often see many other attributes and tags at or near the top-level of the document.
Many of these are unnecessary, or only necessary in very specific contexts.
Most likely, they are there either to support legacy browsers or versions of the SVG spec, or to provide a specific SVG editing software with supplemental metadata to aid editing.
When in doubt, just remove a line and see if it still works.

The `xmlns` attribute is a namespace that simply tells the viewing software that the XML document is meant to be parsed as an SVG.
It is always required, except in the rare case that you are including an SVG directly (inline) in an HTML document.
ome advanced SVG features require you to provide additional namespaces as well.



#### The `viewBox` attribute

The viewbox is the window into the SVG's coordinate space, and defines the boundaries of the image.
You can think of it like a camera or a frame, or as the cropped area of the scene.
You specify the x/y coordinates of the upper left corner and the width/height of the viewbox, in SVG units.

```xml
<svg
  viewBox="x y width height"
  viewBox="70 60 100 75"
>
```
{:.col}

{% include code-image.html src="2-basics/viewbox.svg" %}

Contents of the SVG can extend beyond the viewbox, which you may or may not be able to see depending on the software and the overflow property.

`viewBox` should always be specified; weird things can happen if it isn't.



#### Width and height

The `width` and `height` attributes indicate how wide and high the viewbox (the image) should appear -- in real world size -- in its final context.
They are the only SVG attributes that should have a specified unit.
If no unit is specified, they are interpreted as pixels.

```xml
<svg
  width="..." height="..."
  width="4in" height="3in"
>
```
{:.col}

{% include code-image.html src="2-basics/width-height.svg" %}

Along with `viewBox`, these attributes essentially define a mapping from SVG units to real world units.

If these attributes are omitted entirely, default behavior will vary from software to software.
Browsers will usually scale the image to fit the dimensions of its container.
Some software may make them the same as the viewbox width/height in pixels.
If you specify only one of these attributes, the other dimension will scale proportionally (preserving aspect ratio).

In practice, it is often more useful to not hard-code these attributes into the SVG, and to simply scale the image in situ to the needed size (eg, in CSS for a webpage, or in Inkscape before rendering as a PNG).
As such, the minimum/boilerplate code to form a valid SVG is an `<svg>` element with the `xmlns` and `viewBox` attributes.



#### Units

It is actually possible to specify coordinates/dimensions/etc in terms of "real world units" like inches, but it is typically not advisable.

```
"1px"  →  "1"
"1in"  →  "96"
"1cm"  →  "37.795"
"1pt"  →  "1.333"
```
{:.col}

{% include code-image.html src="2-basics/units.svg" %}

Any time a real world unit is written, it first gets converted to SVG units based on constants defined in the SVG standard.
Then, the element is positioned and scaled within (relative to) the viewbox you specified.
Then, the viewbox is sized by the viewing software to make the image appear the real world width and height you specified, (hopefully) considering on your monitor's resolution/dpi.


Because of this pipeline, specifying real world units is prone to error.
You might not produce the actual size you intend.


**Bottom line**: write SVGs without units, except for the `width` and `height` attributes on the `<svg>` element itself.
It is standard practice; and most SVG editing software seems to generate SVGs in this manner by default.
It is also in line with the main purpose of SVGs, which is to create images that are independent of actual size.

[Units reference](https://oreillymedia.github.io/Using_SVG/guide/units.html)



#### Units example

```xml
<svg
  viewBox="0 0 96 96"
  width="4in"
  height="4in"
>
  ...a square with width and height set to "0.5in", centered in the viewbox
</svg>
```

Consider the above example.
Assuming the software that views the SVG does a good job, what should be the final real world size of the square?  
Answer: <span class="spoiler">2in x 2in</span>



#### Stroke and fill

Before getting into drawing basic shapes, it is necessary to understand the stroke and fill attributes.
The stroke is the outline of a shape, and the fill is the area within a shape.
Both attributes can be set to a color, or to `none` to be disabled.

```xml
<element
  fill="..."     stroke="..."
  fill="skyblue" stroke="blue"
>
```
{:.col}

{% include code-image.html src="2-basics/fill-stroke.svg" %}

By default, SVG shapes have `fill="black"` and `stroke="none"`; even shapes that are intended to be just strokes, like lines.
You will likely have to override this frequently.

By default, the stroke is shown in front of the fill.
Unfortunately, there isn't a reliable, fully accepted way (for all browsers and software) to switch this order.

Special note: you may also come across the value `currentColor`.
This makes the fill or stroke match the "active" color in whatever is viewing the SVG.
This is really only relevant in web development, where for example you may want an SVG icon to automatically match the color of the text it is inline with.
If there is no "current color" to use, it will default to black.



#### Color

Color theory is a complex topic that merits its own independent study.
But for the purposes of being able to dive right into creating images, here is a brief explanation.

There are several ways to specify colors in SVG:
<div class="table_container" markdown="1">

| Method                     | Normal (opaque)    | With transparency        |
|:---------------------------|:------------------:|:------------------------:|
| Named                      | `red`              | -                        |
| Hex                        | `#ff0000`          | `#ff000080`              |
| Red, Green, Blue           | `rgb(255, 0, 0)`   | `rgba(255, 0, 0, 0.5)`   |
| Hue, Saturation, Luminance | `hsl(0, 0%, 100%)` | `hsla(0, 0%, 100%, 0.5)` |

</div>

**HSL** splits colors into **hue** (_what_ color it is, red vs green vs purple), **saturation** (how _much_ color there is, black/white vs colorful), and **luminance** (how bright it is, dark vs light).

{% include figure.html src="2-basics/colors.png" caption="hue, saturation, luminance" class="unset_img" %}

**RGB** splits colors into **red**/**green**/**blue** components, between `0` and `255` (256 possible values). Balance the components in different proportions to get different hues. Increase/decrease all of the components to increase/decrease the brightness. All `0`'s = black, all `255`'s = white.

**Hex** is just a more compact way to write RGB. The 0 to 255 range is compressed down to 2 hex digits, each with 16 possible values (`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `A`, `B`, `C`, `D`, `E`, `F`). The first two digits represent red, the next two green, and the next two blue. Hex colors are the most common way to write colors in web technologies. 

**Named** simply uses regular (English) color names, like `red` or `violet`.

Non-named colors can also accept an additional **alpha** (`a`) parameter at the end, which will blend it with whatever content is behind it.

[A nice color palette](https://www.materialpalette.com/colors)  
[Another nice color palette](https://htmlcolorcodes.com/color-chart/)  
[AI generated color palettes](http://colormind.io/)  
[Nice pairs of colors for gradients](http://www.gradients.io/)



#### Opacity

An element's opacity defines how much it will blend in with whatever content is behind it, on a scale of `0` to `1`. An opacity of `1` will make an element completely opaque; `0` completely invisible; `0.5` half-way translucent.

```xml
<element
  opacity="..."
  opacity="0.5"
>
```
{:.col}

{% include code-image.html src="2-basics/opacity.svg" %}

There are also `fill-opacity` and `stroke-opacity` attributes to set the transparency of the fill and stroke separately, but they are not broadly supported yet. Use with caution.



#### Z-order

Elements are stacked in the order they appear in your SVG document.
Later defined elements are stacked on-top/in-front of earlier defined elements.


```xml
<!-- 1 -->
<rect />
<!-- 2 -->
<rect />
<!-- 3 -->
<rect />
```
{:.col}

{% include code-image.html src="2-basics/z-order.svg" %}
